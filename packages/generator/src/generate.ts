import * as fs from "node:fs";
import * as path from "node:path";
import type { FlagManifest, FlagControlConfig } from "@flagcontrol/core";
import { createLoader } from "@flagcontrol/core";

export async function generateTypes(
    config: FlagControlConfig,
    outputPath: string,
    preloadedFlags?: any[]
) {
    console.log("Fetching flags...");

    try {
        let flags: FlagManifest[] = [];
        if (preloadedFlags) {
            flags = preloadedFlags;
        } else {
            const loader = createLoader(config);
            flags = await loader.getManifest();
        }
        console.log({ flags, rules: flags?.map((flag) => flag.rules), defaults: flags?.map((flag) => flag.defaults) });
        console.log(`Found ${flags?.length ?? 0} flags. Generating types...`);

        const lines = [
            "// This file is auto-generated by FlagControl. Do not edit manually.",
            "",
            "import type { FlagControlRegister } from \"@flagcontrol/core\";",
            "",
            "export type FlagControlAppFlags = {",
        ];

        for (const flag of (flags ?? [])) {
            let typeStr = "unknown";

            const valueTypes = new Set<string>();

            // Collect values from variants
            if (flag.variants && Array.isArray(flag.variants)) {
                for (const variant of flag.variants) {
                    if (typeof variant === "string") {
                        valueTypes.add(`"${variant}"`);
                    } else if (typeof variant === "number" || typeof variant === "boolean") {
                        valueTypes.add(String(variant));
                    } else if (typeof variant === "object") {
                        valueTypes.add("Record<string, unknown>");
                    }
                }
            }

            // Collect values from defaults and rules
            if (flag.rules && Array.isArray(flag.rules)) {
                for (const val of flag.rules) {
                    if (typeof val === "string") {
                        valueTypes.add(`"${val}"`);
                    } else if (typeof val === "number" || typeof val === "boolean") {
                        valueTypes.add(String(val));
                    }
                }
            }
            if (flag.defaults && Array.isArray(flag.defaults)) {
                for (const val of flag.defaults) {
                    if (typeof val === "string") {
                        valueTypes.add(`"${val}"`);
                    } else if (typeof val === "number" || typeof val === "boolean") {
                        valueTypes.add(String(val));
                    }
                }
            }

            if (flag.type === "string") {
                valueTypes.add("({} & string)");
            } else if (flag.type === "number") {
                valueTypes.add("({} & number)");
            } else if (flag.type === "json") {
                valueTypes.add("({} & Record<string, unknown>)");
            }

            if (valueTypes.size > 0) {
                typeStr = Array.from(valueTypes).join(" | ");
            } else if (flag.type) {
                switch (flag.type) {
                    case "boolean":
                        typeStr = "boolean";
                        break;
                    case "string":
                        typeStr = "string";
                        break;
                    case "number":
                        typeStr = "number";
                        break;
                    case "json":
                        typeStr = "Record<string, unknown>";
                        break;
                    default:
                        typeStr = "unknown";
                }
            }

            lines.push(`    "${flag.key}": ${typeStr};`);
        }

        // lines.push("  }");
        lines.push("};");
        lines.push("");
        lines.push("declare module \"@flagcontrol/core\" {");
        lines.push("  interface FlagControlRegister {");
        lines.push("    flags: FlagControlAppFlags;");
        lines.push("  }");
        lines.push("}");
        lines.push("");

        const content = lines.join("\n");
        const fullPath = path.resolve(process.cwd(), outputPath);

        // Ensure directory exists
        const dir = path.dirname(fullPath);
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }

        fs.writeFileSync(fullPath, content);
        console.log(`Types generated at ${fullPath}`);
    } catch (error) {
        throw new Error(`Failed to generate types: ${error instanceof Error ? error.message : String(error)}`);
    }
}
